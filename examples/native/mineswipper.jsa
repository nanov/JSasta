const NCCS = 20;
const STDIN_FILENO = 0;
const TCSANOW = 0;


// termios.h on osx
struct termios {
	c_iflag: u64;
	c_oflag: u64;
	c_cflag: u64;
	c_lflag: u64;
	cc_cc: u8[20];
	c_ispeed: u64;
	c_ospeed: u64;
}

struct pos {
	x : u8;
	y: u8;
}

// termios.h
external tcgetattr(fd:int, termios_p:termios):int;
external tcsetattr(fd:int, optional_actions:int, termios_p:termios):int;
external isatty(fd:int):int;
// stdid.h
external printf(format:string, ...):void;
external read(fd:int, buf:string, count:int):int;
external write(fd:int, buf:string, count:int):int;


struct game_state {
	cells: bool[100];
	states: i8[100];
	cursour: pos;
	move_up function(self: ref game_state):void {
		if (self.cursour.y > 0)
			self.cursour.y--;
	}
	move_down function(self: ref game_state):void {
		if (self.cursour.y < 10)
			self.cursour.y++;
	}
	move_left function(self: ref game_state):void {
		if (self.cursour.x > 0)
			self.cursour.x--;
	}
	move_right function(self: ref game_state):void {
		if (self.cursoux.x < 10)
			self.cursour.x++;
	}
}


var cells = Array(ROWS*COLS);
var states = Array(ROWS*COLS);
var cursourRow: int = 0;
var cursourCell: int = 0;




function draw_field(r: int, c: int):void {
	const ROWS:int = 10;
	const COLS:int = 10;
	for (let row = 0; row < ROWS; row++) {
		for (let col = 0; col < COLS; col++) {
			const is_at_cursour = row == r && col == c;
			printf(is_at_cursour ? "[" : " ");
			printf(".");
			printf(is_at_cursour ? "]" : " ");
		}
		printf("\n");
	}
}

function redraw_field(): void {
	const ROWS:int = 10;
	const COLS:int = 10;
	printf("\e[%dA", ROWS);
	printf("\e[%dD", COLS*3);
}

var t_o : termios;
var t_original : termios;

// Check if stdin is a terminal
var is_tty:int = isatty(STDIN_FILENO);
printf("Is stdin a TTY? %d\n", is_tty);

// Get current terminal attributes
var result:int = tcgetattr(STDIN_FILENO, t_o);
t_original = t_o;

printf("tcgetattr returned: %d\n", result);
printf("Original c_lflag: %llu (0x%llx)\n", t_o.c_lflag, t_o.c_lflag);

// Turn off canonical mode and echo
// ICANON = 0x00000100, ECHO = 0x00000008
// Mask: ~(ICANON | ECHO) = ~0x108 = 0xFFFFFEF7
var old_lflag:u64 = t_o.c_lflag;
t_o.c_lflag = t_o.c_lflag & 4294966007u64;

printf("Modified c_lflag: %llu (0x%llx)\n", t_o.c_lflag, t_o.c_lflag);
tcsetattr(STDIN_FILENO, TCSANOW, t_o);
printf("tcsetattr returned: %d\n", result);

printf("\nTerminal is now in raw mode. Press keys (q to quit):\n");

// Allocate a buffer for reading input (mutable memory via string concatenation)
var buffer:string = "" + " ";
var game: game_state;
// Read one character

var exit:bool = false;
while(!exit) {
	draw_field(cursourRow, cursourCell);
	var bytes_read:int = read(STDIN_FILENO, buffer, 1);
	if (bytes_read > 0) {
	    var ch = buffer[0];
			if (ch == 113) {
						exit = true;
						break;
			}
			if (ch == 97) {
				game.move_up();
				if (cursourCell>0)
					cursourCell -= 1;
			} else if (ch == 100) {
				if (cursourCell<COLS)
					cursourCell += 1;
			} else if (ch == 115) {
				if (cursourRow<ROWS)
					cursourRow += 1;
			} else if (ch == 119) {
				if (cursourRow>0)
					cursourRow -= 1;
			}
			redraw_field();
	}
}

// Restore original terminal settings
result = tcsetattr(STDIN_FILENO, TCSANOW, t_original);
printf("\nTerminal restored to normal mode. code: %d\n", result);

const NCCS = 20; // seen on mac
const STDIN_FILENO = 0;
const TCSANOW = 0;

const ROWS:int = 10;
const COLS:int = 10;



// until we implemnt arrays in structs, this is my solution :/
struct termios {
	c_iflag: u64=0u64;
	c_oflag: u64=0u64;
	c_cflag: u64=0u64;
	c_lflag: u64=0u64;
	cc_cc1: u8=0u8;
	cc_cc2: u8=0u8;
	cc_cc3: u8=0u8;
	cc_cc4: u8=0u8;
	cc_cc5: u8=0u8;
	cc_cc6: u8=0u8;
	cc_cc7: u8=0u8;
	cc_cc8: u8=0u8;
	cc_cc9: u8=0u8;
	cc_cc10: u8=0u8;
	cc_cc11: u8=0u8;
	cc_cc12: u8=0u8;
	cc_cc13: u8=0u8;
	cc_cc14: u8=0u8;
	cc_cc15: u8=0u8;
	cc_cc16: u8=0u8;
	cc_cc17: u8=0u8; // VMIN
	cc_cc18: u8=0u8; // VTIME
	cc_cc19: u8=0u8;
	cc_cc20: u8=0u8;
	c_ispeed: u64=0u64;
	c_ospeed: u64=0u64;
}

// termios.h
external tcgetattr(fd:int, termios_p:termios):int;
external tcsetattr(fd:int, optional_actions:int, termios_p:termios):int;
external isatty(fd:int):int;
// stdid.h
external printf(format:string, ...):void;
external read(fd:int, buf:string, count:int):int;
external write(fd:int, buf:string, count:int):int;

var cells = Array(ROWS*COLS);
var states = Array(ROWS*COLS);
var cursourRow: int = 0;
var cursourCell: int = 0;




function draw_field(r: int, c: int):void {
	const ROWS:int = 10;
	const COLS:int = 10;
	for (let row = 0; row < ROWS; row++) {
		for (let col = 0; col < COLS; col++) {
			const is_at_cursour = row == r && col == c;
			printf(is_at_cursour ? "[" : " ");
			printf(".");
			printf(is_at_cursour ? "]" : " ");
		}
		printf("\n");
	}
}

function redraw_field(): void {
	const ROWS:int = 10;
	const COLS:int = 10;
	printf("\e[%dA", ROWS);
	printf("\e[%dD", COLS*3);
}

var t_o:termios = {};
var t_original:termios = {};

// Check if stdin is a terminal
var is_tty:int = isatty(STDIN_FILENO);
printf("Is stdin a TTY? %d\n", is_tty);

// Get current terminal attributes
var result:int = tcgetattr(STDIN_FILENO, t_o);
tcgetattr(STDIN_FILENO, t_original);

printf("tcgetattr returned: %d\n", result);
printf("Original c_lflag: %llu (0x%llx)\n", t_o.c_lflag, t_o.c_lflag);

// Turn off canonical mode and echo
// ICANON = 0x00000100, ECHO = 0x00000008
// Mask: ~(ICANON | ECHO) = ~0x108 = 0xFFFFFEF7
var old_lflag:u64 = t_o.c_lflag;
t_o.c_lflag = t_o.c_lflag & 4294966007u64;
t_o.cc_cc17 = 1;
t_o.cc_cc18 = 0;
printf("Modified c_lflag: %llu (0x%llx)\n", t_o.c_lflag, t_o.c_lflag);
// Apply the modified attributes immediately
result = tcsetattr(STDIN_FILENO, TCSANOW, t_o);
printf("tcsetattr returned: %d\n", result);

printf("\nTerminal is now in raw mode. Press keys (q to quit):\n");

// Allocate a buffer for reading input (mutable memory via string concatenation)
var buffer:string = "" + " ";

// Read one character

var exit:bool = false;
while(!exit) {
	draw_field(cursourRow, cursourCell);
	var bytes_read:int = read(STDIN_FILENO, buffer, 1);
	if (bytes_read > 0) {
	    var ch = buffer[0];
			if (ch == 113) {
						exit = true;
						break;
			}
			if (ch == 97) {
				if (cursourCell>0)
					cursourCell -= 1;
			} else if (ch == 100) {
				if (cursourCell<COLS)
					cursourCell += 1;
			} else if (ch == 115) {
				if (cursourRow<ROWS)
					cursourRow += 1;
			} else if (ch == 119) {
				if (cursourRow>0)
					cursourRow -= 1;
			}
			redraw_field();
	}
}

// Restore original terminal settings
tcsetattr(STDIN_FILENO, TCSANOW, t_original);
printf("\nTerminal restored to normal mode.\n");

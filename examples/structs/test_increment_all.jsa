struct pos {
    x : u8;
    y: u8;
}

struct game_state {
    cursour: pos;

    // Test 1: Postfix in struct method with ref self
    inc_postfix function(self: ref game_state):u8 {
        return self.cursour.x++;
    }

    // Test 2: Prefix in struct method with ref self
    inc_prefix function(self: ref game_state):u8 {
        return ++self.cursour.y;
    }

    // Test 3: Decrement postfix
    dec_postfix function(self: ref game_state):u8 {
        return self.cursour.x--;
    }

    // Test 4: Decrement prefix
    dec_prefix function(self: ref game_state):u8 {
        return --self.cursour.y;
    }
}

// Test 5: Regular function with ref parameter
function test_ref_postfix(p: ref pos):u8 {
    return p.x++;
}

// Test 6: Regular function with ref parameter - prefix
function test_ref_prefix(p: ref pos):u8 {
    return ++p.y;
}

// Test 7: Regular function with ref parameter - nested access
function test_ref_nested(g: ref game_state):u8 {
    g.cursour.x++;
    return ++g.cursour.y;
}

// Test 8: Non-ref global variable
var global_pos: pos;

function test_global_postfix():u8 {
    return global_pos.x++;
}

function test_global_prefix():u8 {
    return ++global_pos.y;
}

// Test 9: Local variable (non-ref)
function test_local():u8 {
    var local_pos: pos;
    local_pos.x = 5;
    local_pos.x++;
    return ++local_pos.x;
}

// Test 10: Verify return values are correct
function verify_postfix_returns_old():u8 {
    var p: pos;
    p.x = 10;
    var old = p.x++;  // Should return 10
    // p.x should now be 11
    return old;
}

function verify_prefix_returns_new():u8 {
    var p: pos;
    p.y = 20;
    var new = ++p.y;  // Should return 21
    // p.y should be 21
    return new;
}
